program ColdWar;
var
	// Address of bitmap (screen and characters)
	@userdata $1000 $1FFF "Bitmap"

	// Export sprites, tiles and font from FLUFF files (creates .bin files)
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_carbody.bin"    0 	12	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_wheel.bin"      80 	88	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_ground.bin"     160	162	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_updown.bin"     120	128	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_upperlevel.bin" 360	368	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_letters.bin"    400	412	2	1
	@export		"res/char/font4x8.flf" 		"export/font4x8.bin"           0 	64

	// Create images for eprom burning (for 16kB cartridge)
	@exportprg2bin "coldwar.prg" "eprom2000.bin" $2000 $4000
	@exportprg2bin "coldwar.prg" "eproma000.bin" $a000 $c000


	// Memory addresses for sprites & tiles
	const addrMusic:	address = $be00;
	const addrCarBody:	address = $3800;
	const addrWheel:	address = addrCarBody + 96;
	const addrGround:	address = addrWheel + 64;
	const addrUpdown:	address = addrGround + 16;
	const addrFont:		address = addrUpdown + 64;
	const addrUpper:	address = addrFont + 512;

	// Virtual
	const addrNumbers:	address = addrFont + 384;

	// Include exported resources into binary at specified address
	carSprite: incbin("export/sprite_carbody.bin", addrCarBody);
	wheelSprite: incbin("export/sprite_wheel.bin", addrWheel);
	groundTile: incbin("export/sprite_ground.bin", addrGround);
	updownTile: incbin("export/sprite_updown.bin", addrUpdown);
	smallFont: incbin("export/font4x8.bin", addrFont);
	upperLevel: incbin("export/sprite_upperlevel.bin", addrUpper);
	
	// Import music data. Made with Fisichella, song by Jojeli
	musicData: incbin("export/imono.bin", addrMusic);
	
	// Pre-shifted address-table for car body sprite
	carbody_L: array[] of integer = (
		addrCarBody, addrCarBody+24, addrCarBody+48, addrCarBody+72
	);
	carbody_M: array[] of integer = (
		addrCarBody+8, addrCarBody+32, addrCarBody+56, addrCarBody+80
	);
	carbody_R: array[] of integer = (
		addrCarBody+16, addrCarBody+40, addrCarBody+64, addrCarBody+88
	);
	
	// Address-table for ground tiles
	ground_T: array[] of integer = (
		addrGround, addrGround + 8
	);

	// Address-table for up'n'down tiles
	updown_T: array[] of integer = (
		addrUpDown, addrUpDown+8, addrUpDown+16, addrUpDown+24,
		addrUpDown+32, addrUpDown+40, addrUpDown+48, addrUpDown+56
	);

	// Address-table for upper level tiles
	upper_T: array[] of integer = (
		addrUpper, addrUpper+8, addrUpper+16, addrUpper+24,
		addrUpper+32, addrUpper+40, addrUpper+48, addrUpper+56
	);


	// Pre-shifter address-table for single wheel sprite
	wheel_L: array[] of integer = (
		addrWheel, addrWheel+16, addrWheel+32, addrWheel+48
	);
	wheel_R: array[] of integer = (
		addrWheel+8, addrWheel+24, addrWheel+40, addrWheel+56
	);


	// Misc constants
	const MULTICOLOR: byte = 8;

	// Draw tree index
	const d_car: 	byte = 0;
	const d_grnd:	byte = 1;
	const d_upper:	byte = 2;

	// State index
	const s_stat:	byte = 0;
	const s_move:	byte = 1;
	const s_jump:	byte = 2;

	// X direction while jumping
	const x_none:	byte = 0;
	const x_left:	byte = 1;
	const x_right:	byte = 2;

// Include variables. Defined in zeropage and cassette buffer
@include "variables.ras"

// External procedures
@include "musicplayer.ras"
@include "initvars.ras"

// Interrupt function that handles all the screen drawing
// starting from certain raster line to avoid flicker
//
procedure drawcar();
begin
	// Store the processors registers
	StartIRQ(0); 	
	// Play song
//				screen_bg_color := WHITE + SCREEN_BG_BLACK;
	asm("    jsr MusicPlay");

//				screen_bg_color := BLACK + SCREEN_BG_BLACK;

	// Clear previous car sprite
	vbmSetPosition2(old_x, old_y + old_y_off+2);
	vbmDrawSprite2E(carbody_L, carbody_M, carbody_R);
	
	// Clear old wheels
	vbmSetPosition2(old_x, old_wh_y + old_wl_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(old_x+10, old_wh_y + old_wr_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);

//	if (scnt & 1) then
	begin
		vbmScreenShiftLeft(176,192);
		vbmScreenShiftLeft(176,192);
	end;

	if (uscnt = 0) then
	begin
		vbmScreenShiftLeft(134,142);
		vbmScreenShiftLeft(134,142);
	end;

	// Stars
	if (bcnt = 0) then
	begin
		vbmScreenShiftLeft(50, 51);
		vbmScreenShiftLeft(70, 71);
		vbmScreenShiftLeft(90, 91);
	end;
	if (mcnt = 0) then
	begin
		vbmScreenShiftLeft(40, 41);
		vbmScreenShiftLeft(60, 61);
		vbmScreenShiftLeft(80, 81);
	end;
	
	// Draw new ground piece
	if (drawTree[d_grnd] = 1 and gcnt = 0) then
	begin
		vbmSetPosition2(152, 176);
		p1 := int2ptr(updown_T[updowntile]);
		vbmDrawTile(p1);
		drawTree[d_grnd] := 0;
	end;

	// Draw new upper level piece
	if (drawTree[d_upper] = 1 and ucnt = 0) then
	begin
		vbmSetPosition2(152, 134);
		p1 := int2ptr(upper_T[uppertile]);
		vbmDrawTile(p1);
		drawTree[d_upper] := 0;
	end;


	// Draw new car sprite
	vbmSetPosition2(bx, by + y_off+2);
	vbmDrawSprite2(carbody_L, carbody_M, carbody_R);
	
	// Draw wheels
	vbmSetPosition2(bx, wh_y + wl_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(bx + 10, wh_y + wr_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);
	drawTree[d_car] := 0;
	old_x := bx;
	old_y := by;
	old_y_off := y_off;
	old_wh_y := wh_y;
	old_wl_y_off := wl_y_off;
	old_wr_y_off := wr_y_off;

	// Increase counters
	inc(scnt);
	incrange(gcnt, 0, 4);
	incrange(mcnt, 0, 2);
	incrange(bcnt, 0, 3);
	incrange(ucnt, 0, 16);
	incrange(uscnt, 0, 4);

//				screen_bg_color := BLUE + SCREEN_BG_BLACK;

	// Restore the processor registers and complete our interrupt
	closeIRQ();
end;

// Limit buggy x movement
procedure limit_x();
begin
	if (bx < 8) then bx := 8;
	if (bx > 120) then bx := 120;
end;

// Move buggy right
procedure buggy_right(incamount:byte at $3a);
begin
	bx := bx + incamount;
	xdir := x_right;
end;

// Move buggy left
procedure buggy_left(decamount:byte at $3b);
begin
	bx := bx - decamount;
	xdir := x_left;
end;

// Jump suspension
procedure jumpsuspend();
begin
	// Suspension
	suspension[sus_y] := by;
	wh_y := suspension[sus_wy];
	incrange(sus_y, 0, 3);
	incrange(sus_wy, 0, 3);
end;

// Find ground offset at x+offset
procedure find_ground(xoffset:byte at $3c);
begin
	for i := 0 to 8 do if (vbmTestPixel2(bx+xoffset, 175+i) = 0) then yoff := i;
end;


// This procedure is never actually called in the code, 
// it contains the "cartridge autostart signature" and jump
// address. block1 equals to main. 
@startblock $a000 "Block5"
procedure cartAutostart();
begin
	asm("
	dc.b <block1,>block1       ; Cart reset address
	dc.b <block1,>block1       ; Restore keypress address
	dc.b $41,$30,$c3,$c2,$cd   ; Signature for cart autostart (a0CBM)
	");
end;
@endblock

// Main body, handle all initialization and
// game logic and joystick controls.
begin
	// Initialize system when run as cartridge
	asm("
	jsr $FD8D
	jsr $FD52
	jsr $FDF9
	jsr $E518
	cli
	");

	// Init variables
	initVariables();

	// Init music player
	musicplayer(1);

	// Initialize display mode to 19 column
	vbmSetDisplayMode(1);
	
	// Clear VBM
	vbmClear(0);
	
	// Clear color memory with WHITE and set MULTICOLOR flag
	vbmClearColor(WHITE + MULTICOLOR);
	
	// Set other colors, plus audio volume
	AUX_COLOR_AND_VOLUME := RED * 15 + 15;
	screen_bg_color := BLUE + SCREEN_BG_BLACK;

	for i:=0 to 20 do
	begin
		vbmSetPosition2(i*8, 184);
		p1 := int2ptr(ground_T[grndtile]);
		vbmDrawTile(p1);
		grndtile := grndtile xor 1;
	end;

	// Draw "stars"
	fori i := 0 to 5 do
	begin
		vbmDrawDot((random() >> 2) + 8, 40 + (i * 10));
		vbmDrawDot((random() >> 2) + 88 , 40 + (i * 10));
	end;

    // Draw "title" text
    vbmDrawSmallTextE(scoretitle, smallFont, 0, 0, 6);
    
	// Set upper two rows to hires single color
	fill(screen_col_loc, WHITE, 20);

	// Set up an raster interrupt to call outside visible screen,
	// params: IRQ function, raster line, PAL/NTSC (0/1)
	DisableVIC20IRQ();
	VIARasterIRQ(drawcar(), 124, 0);


	// Main game logic runs here in loop
	while(true) offpage do
	begin
		// Read joystick
		readjoy1();

		// Handle buggy drawing and moving when IRQ says the car has
		// been redrawn
		if (drawTree[d_car] = 0 and mcnt = 0) then
		begin
			case state of
				// Stationery
				s_stat:
					begin
						xdir := x_none;
						if (joy1 & JOY_RIGHT) then buggy_right(2);
						if (joy1 & JOY_LEFT) then buggy_left(2);
						if (joy1 & JOY_UP) then state := s_jump;
						drawTree[d_car] := 1;
					end;
				// In jump
				s_jump:
					begin
						if (xdir = x_right) then buggy_right(1);
						if (xdir = x_left) then buggy_left(1);
						if (jdir = 0) then by:=by-2 else by:=by+2;
						if (by < 110) then jdir := 1;
						if (by = 156) then
						begin
							jdir := 0;
							state := s_stat;
						end;

						drawTree[d_car] := 1;
					end;
			end;

			// make buggy stay inside limits			
			limit_x();

			// calculate new y offset for buggy and wheels
			find_ground(8);
			y_off := yoff;
			find_ground(2);
			wl_y_off := yoff;
			find_ground(12);
			wr_y_off := yoff;
			jumpsuspend();
		end;

		// Set up next ground tile when IRQ says ground needs new
		// tile
		if (drawTree[d_grnd] = 0) then
		begin
			drawTree[d_grnd] := 1;
			updowntile := updowntile + updowndir;
			if (updowntile = 7 or updowntile = 0) then begin
				updowndir := updowndir xor 254;
			end;
		end;

		// Set up next upper level tile when IRQ says ground needs new
		// tile
		if (drawTree[d_upper] = 0) then
		begin
			uppertile := uppertile + upperdir;
			if (uppertile = 7 or uppertile = 0) then begin
				upperdir := upperdir xor 254;
			end;
			bcdadd(score, scoreadd, 3);
			vbmdrawsmallbcd(score, addrNumbers, 6, 0, 3);
			drawTree[d_upper] := 1;
		end;

	end;

end.
