program ColdWar;
var
   
	// Address of bitmap (screen and characters)
	@userdata $1000 $1FFF "Bitmap"

	// Export sprites
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_carbody.bin"		0 	12	2	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_wheel.bin"  		80 	88	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_ground.bin" 		160	162	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_updown.bin" 		120	128	1	1
	@export		"res/char/font4x8.flf" 		"export/font4x8.bin" 			0 	64

	// Resource memory
	const addrCarBody:	address = $3000;
	const addrWheel:	address = addrCarBody + 192;
	const addrGround:	address = addrWheel + 64;
	const addrUpdown:	address = addrGround + 16;
	const addrFont:		address = addrUpdown + 64;

	carSprite: incbin("export/sprite_carbody.bin", addrCarBody);
	wheelSprite: incbin("export/sprite_wheel.bin", addrWheel);
	groundTile: incbin("export/sprite_ground.bin", addrGround);
	updownTile: incbin("export/sprite_updown.bin", addrUpdown);
	smallFont: incbin("export/font4x8.bin", addrFont);

	@startblock $2000 "game"

	// pre-shifted address-table for car body
	carbody_L: array[] of integer = (
		addrCarBody, addrCarBody+48, addrCarBody+96, addrCarBody+144
	);
	carbody_M: array[] of integer = (
		addrCarBody+16, addrCarBody+64, addrCarBody+112, addrCarBody+160
	);
	carbody_R: array[] of integer = (
		addrCarBody+32, addrCarBody+80, addrCarBody+128, addrCarBody+176
	);
	
	// Address-table for ground tile
	ground_T: array[] of integer = (
		addrGround, addrGround + 8
	);

	// Address-table for up'n'down tile
	updown_T: array[] of integer = (
		addrUpDown, addrUpDown+8, addrUpDown+16, addrUpDown+24,
		addrUpDown+32, addrUpDown+40, addrUpDown+48, addrUpDown+56
	);

	// pre-shifter address-table for single wheel
	wheel_L: array[] of integer = (
		addrWheel, addrWheel+16, addrWheel+32, addrWheel+48
	);
	wheel_R: array[] of integer = (
		addrWheel+8, addrWheel+24, addrWheel+40, addrWheel+56
	);

	// Draw tree index
	const d_car: 	byte = 0;
	const d_grnd:	byte = 1;

	// State index
	const s_stat:	byte = 0;
	const s_move:	byte = 1;
	const s_jump:	byte = 2;

	const x_none:	byte = 0;
	const x_left:	byte = 1;
	const x_right:	byte = 2;

	drawTree: array[] of byte = (
		0, 0
	);

	const MULTICOLOR: byte = 8;

	scnt: byte = 0;
	gcnt: byte = 0;
	mcnt: byte = 0;

	x: byte = 50;
	y: byte = 156;
	yr: byte = 160;
	yl: byte = 160;
	oldyr: byte = 180;
	oldyl: byte = 180;
	oldx: byte = 168;
	oldy: byte = 156;
	dir: byte = 2;
	delay: byte;
	clr: byte = 0;
	grndtile: byte = 0;
	updowntile: byte = 0;
	updowndir: byte = 1;
	groundpos: byte = 0;
	groundmoved: byte = 0;
	i: byte = 0;
	p1: pointer;
	yoff: byte = 0;
	yoff_r: byte = 0;
	yoff_l: byte = 0;
	wheelbump: byte = 0;
	state: byte = 0;
	xdir: byte = 0;
	jdir: byte = 0;
    message: cstring = ("COLD WAR - little buggy game");

procedure drawcar();
begin
	StartIRQ(0);  // store the processors registers

	//screen_bg_color := RED + SCREEN_BG_BLACK;

	// Clear previous car sprite
	vbmSetPosition2(oldx, oldy);
	vbmDrawSpriteSliceE(carbody_L, 0, 8);
	vbmNextColumn();
	vbmDrawSpriteSliceE(carbody_M, 0, 8);
	vbmNextColumn();
	vbmDrawSpriteSliceE(carbody_R, 0, 8);
	vbmSetPosition2(oldx, oldy + oldyl + 6);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(oldx+10, oldy + oldyr + 7);
	vbmDrawSprite8E(wheel_L, wheel_R);

	if (scnt & 1) then
	begin
		vbmScreenShiftLeft(176,192);
		vbmScreenShiftLeft(176,192);
	end;
	
	// Draw new ground piece
	if (drawTree[d_grnd] = 1 and gcnt = 0) then
	begin
		vbmSetPosition2(152, 176);
		p1 := int2ptr(updown_T[updowntile]);
		vbmDrawTile(p1);
		drawTree[d_grnd] := 0;
	end;

	// Draw new car sprite
	vbmSetPosition2(x, y);
	vbmDrawSpriteSliceE(carbody_L, 0, 8);
	vbmNextColumn();
	vbmDrawSpriteSliceE(carbody_M, 0, 8);
	vbmNextColumn();
	vbmDrawSpriteSliceE(carbody_R, 0, 8);
	vbmSetPosition2(x, y + yl + 6);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(x+10, y + yr + 7);
	vbmDrawSprite8E(wheel_L, wheel_R);
	drawTree[d_car] := 0;
	oldx := x;
	oldy := y;
	oldyr := yr;
	oldyl := yl;

	//screen_bg_color := BLUE + SCREEN_BG_BLACK;

	// Increase counters
	inc(scnt);
	gcnt := (gcnt + 1) & 7;
	mcnt := (mcnt + 1) & 1;

	closeIRQ(); // restore the processor registers and complete our interrupt
end;

procedure limit_x();
begin
	if (x < 20) then x := 20;
	if (x > 120) then x := 120;
end;

begin
	vbmSetDisplayMode(1);
	vbmClear(0);
	vbmClearColor(WHITE + MULTICOLOR);
	AUX_COLOR_AND_VOLUME := RED * 15 + 15;
	screen_bg_color := BLUE + SCREEN_BG_BLACK;

	for i:=0 to 20 do
	begin
		vbmSetPosition2(i*8, 184);
		p1 := int2ptr(ground_T[grndtile]);
		vbmDrawTile(p1);
		grndtile := grndtile xor 1;
	end;

    // draw text
    vbmDrawSmallTextE(message, smallFont, 5, 1, 6);
    
	fill(screen_col_loc, WHITE, 20);

	DisableVIC20IRQ();
	
	// Set up an raster interrupt to call outiside visible screen,
	// params: IRQ function, raster line, PAL/NTSC (0/1)
	VIARasterIRQ(drawcar(), 112, 0);


	while(true) offpage do
	begin
		// Read joystick
		readjoy1();
		
		// Basic movement and wheel wobble
		if ((drawTree[d_car] = 0 and mcnt = 0) and state = s_stat) then
		begin
			//screen_bg_color := GREEN + SCREEN_BG_BLACK;
			// calculate new y offset for buggy and wheels
			for i := 0 to 8 do if (vbmTestPixel2(x+8, 176+i) = 0) then yoff := i;
			y := 156 + yoff;
			for i := 0 to 8 do if (vbmTestPixel2(x, 176+i) = 0) then yoff := i;
			yl := (yoff >> 1) + wheelbump;
			for i := 0 to 8 do if (vbmTestPixel2(x+16, 176+i) = 0) then yoff := i;
			yr := (yoff >> 1) + wheelbump;
			wheelbump := wheelbump xor 1;
			xdir := x_none;
			if (joy1 & JOY_RIGHT) then
			begin
				x := x + 2;
				xdir := x_right;
			end;
			if (joy1 & JOY_LEFT) then
			begin
				x := x - 2;
				xdir := x_left;
			end;
			if (joy1 & JOY_DOWN) then
			begin
				state := s_jump;
			end;
			//if (x = oldx) then x:=x-2;
			limit_x();
			//screen_bg_color := BLUE + SCREEN_BG_BLACK;
			drawTree[d_car] := 1;
		end;
		
		// Jump
		if ((drawTree[d_car] = 0 and mcnt = 0) and state = s_jump) then
		begin
			if (xdir = x_right) then x:=x + 2;
			if (xdir = x_left) then x:=x - 2;
			limit_x();
			if (jdir = 0) then y:=y-2 else y:=y+2;
			if (y < 140) then jdir := 1;
			if (y > 164) then
			begin
				jdir := 0;
				state := s_stat;
			end;
			drawTree[d_car] := 1;
		end;

		// Set up next ground tile
		if (drawTree[d_grnd] = 0) then
		begin
			drawTree[d_grnd] := 1;
			updowntile := updowntile + updowndir;
			if (updowntile = 7 or updowntile = 0) then begin
				updowndir := updowndir xor 254;
			end;
		end;
	end;
end.
