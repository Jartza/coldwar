program ColdWar;
var
	// Address of bitmap (screen and characters)
	@userdata $1000 $1FFF "Bitmap"

	// Export sprites, tiles and font from FLUFF files (creates .bin files)
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_carbody.bin"		0 	12	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_wheel.bin"  		80 	88	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_ground.bin" 		160	162	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_updown.bin" 		120	128	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_upperlevel.bin" 	360	368	1	1
	@export		"res/char/font4x8.flf" 		"export/font4x8.bin" 			0 	64

	// Memory addresses for sprites & tiles
	const addrCarBody:	address = $3200;
	const addrWheel:	address = addrCarBody + 96;
	const addrGround:	address = addrWheel + 64;
	const addrUpdown:	address = addrGround + 16;
	const addrFont:		address = addrUpdown + 64;
	const addrUpper:	address = addrFont + 512;
	const addrMusic:	address = $3600;

	// Virtual
	const addrNumbers:	address = addrFont + 384;

	// Include exported resources into binary at specified address
	carSprite: incbin("export/sprite_carbody.bin", addrCarBody);
	wheelSprite: incbin("export/sprite_wheel.bin", addrWheel);
	groundTile: incbin("export/sprite_ground.bin", addrGround);
	updownTile: incbin("export/sprite_updown.bin", addrUpdown);
	smallFont: incbin("export/font4x8.bin", addrFont);
	upperLevel: incbin("export/sprite_upperlevel.bin", addrUpper);
	musicData: incbin("export/imono.bin", @addrMusic);

	@startblock $2000 "game"
	
	// Pre-shifted address-table for car body sprite
	carbody_L: array[] of integer = (
		addrCarBody, addrCarBody+24, addrCarBody+48, addrCarBody+72
	);
	carbody_M: array[] of integer = (
		addrCarBody+8, addrCarBody+32, addrCarBody+56, addrCarBody+80
	);
	carbody_R: array[] of integer = (
		addrCarBody+16, addrCarBody+40, addrCarBody+64, addrCarBody+88
	);
	
	// Address-table for ground tiles
	ground_T: array[] of integer = (
		addrGround, addrGround + 8
	);

	// Address-table for up'n'down tiles
	updown_T: array[] of integer = (
		addrUpDown, addrUpDown+8, addrUpDown+16, addrUpDown+24,
		addrUpDown+32, addrUpDown+40, addrUpDown+48, addrUpDown+56
	);

	// Address-table for upper level tiles
	upper_T: array[] of integer = (
		addrUpper, addrUpper+8, addrUpper+16, addrUpper+24,
		addrUpper+32, addrUpper+40, addrUpper+48, addrUpper+56
	);


	// Pre-shifter address-table for single wheel sprite
	wheel_L: array[] of integer = (
		addrWheel, addrWheel+16, addrWheel+32, addrWheel+48
	);
	wheel_R: array[] of integer = (
		addrWheel+8, addrWheel+24, addrWheel+40, addrWheel+56
	);


	// Misc constants
	const MULTICOLOR: byte = 8;

	// Draw tree index
	const d_car: 	byte = 0;
	const d_grnd:	byte = 1;
	const d_upper:	byte = 2;

	// State index
	const s_stat:	byte = 0;
	const s_move:	byte = 1;
	const s_jump:	byte = 2;

	// X direction while jumping
	const x_none:	byte = 0;
	const x_left:	byte = 1;
	const x_right:	byte = 2;

	// Drawtree array which handles what to redraw
	drawTree: array[] of byte = (
		0, 0, 0
	);
	
	// Suspension "ring buffer"
	suspension: array[] of byte = (
		0, 0, 156
	);

	// Suspension buffer vars
	sus_y: byte = 0;
	sus_wy: byte = 2;


	// Global variables for all the game logic
	scnt: byte = 0;
	gcnt: byte = 0;
	mcnt: byte = 0;
	bcnt: byte = 0;
	ucnt: byte = 0;
	uscnt: byte = 0;
	
	// Buggy body coordinates, pretty
	// straightforward x and y and y offset
	x: byte = 50;
	y: byte = 156;
	y_off: byte = 0;
	
	// Buggy wheels coordinates,
	// y coordinate and offset for each wheel.
	// x is calculated from body
	wh_y: byte = 156;			// generic wheel y coordinate
	wr_y_off: byte = 0;			// right wheel y offset
	wl_y_off: byte = 0;			// left wheel y offset

	// Storage space for old coordinates,
	// which are used to clear old graphics before
	// drawing new one
	old_x: byte = 168;
	old_y: byte = 156;
	old_y_off: byte = 0;
	old_wh_y: byte = 180;
	old_wr_y_off: byte = 0;		// old right wheel y offset
	old_wl_y_off: byte = 0;		// old left wheel y offset

	// Loop and temp variables, 
	// t used inside IRQ, i used outside IRQ
	i,t: byte = 0;

	// x direction during jump
	xdir: byte = 0;

	// Game main loop state-machine state
	state: byte = 0;

	// Generic pointer, used for tile drawing
	p1: pointer;

	// Used for y offset calculations
	yoff: byte = 0;

	// Jump direction
	jdir: byte = 0;

	// Some misc stuff, probably to be removed later
	grndtile: byte = 0;
	updowntile: byte = 0;
	updowndir: byte = 1;
	uppertile: byte = 0;
	upperdir: byte = 1;
    message: cstring = ("COLD WAR - little buggy game");
    scoretitle: cstring = ("SCORE:");
    score: array[] of byte = ($00, $00, $00);
    scoreadd: array[] of byte = ($01, $00, $00);

	@include "musicplayer.ras"


// Interrupt function that handles all the screen drawing
// starting from certain raster line to avoid flicker
//
procedure drawcar();
begin
	// Store the processors registers
	StartIRQ(0);
	
	// Play song
//				screen_bg_color := WHITE + SCREEN_BG_BLACK;
	musicplayer(0);

//				screen_bg_color := BLACK + SCREEN_BG_BLACK;

	// Clear previous car sprite
	vbmSetPosition2(old_x, old_y + old_y_off+2);
	vbmDrawSprite2E(carbody_L, carbody_M, carbody_R);
	
	// Clear old wheels
	vbmSetPosition2(old_x, old_wh_y + old_wl_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(old_x+10, old_wh_y + old_wr_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);

//	if (scnt & 1) then
	begin
		vbmScreenShiftLeft(176,192);
		vbmScreenShiftLeft(176,192);
	end;

	if (uscnt = 0) then
	begin
		vbmScreenShiftLeft(134,142);
		vbmScreenShiftLeft(134,142);
	end;

	// Stars
	if (bcnt = 0) then
	begin
		vbmScreenShiftLeft(50, 51);
		vbmScreenShiftLeft(70, 71);
		vbmScreenShiftLeft(90, 91);
	end;
	if (mcnt = 0) then
	begin
		vbmScreenShiftLeft(40, 41);
		vbmScreenShiftLeft(60, 61);
		vbmScreenShiftLeft(80, 81);
	end;
	
	// Draw new ground piece
	if (drawTree[d_grnd] = 1 and gcnt = 0) then
	begin
		vbmSetPosition2(152, 176);
		p1 := int2ptr(updown_T[updowntile]);
		vbmDrawTile(p1);
		drawTree[d_grnd] := 0;
	end;

	// Draw new upper level piece
	if (drawTree[d_upper] = 1 and ucnt = 0) then
	begin
		vbmSetPosition2(152, 134);
		p1 := int2ptr(upper_T[uppertile]);
		vbmDrawTile(p1);
		drawTree[d_upper] := 0;
	end;


	// Draw new car sprite
	vbmSetPosition2(x, y + y_off+2);
	vbmDrawSprite2(carbody_L, carbody_M, carbody_R);
	
	// Draw wheels
	vbmSetPosition2(x, wh_y + wl_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(x+10, wh_y + wr_y_off + 10);
	vbmDrawSprite8E(wheel_L, wheel_R);
	drawTree[d_car] := 0;
	old_x := x;
	old_y := y;
	old_y_off := y_off;
	old_wh_y := wh_y;
	old_wl_y_off := wl_y_off;
	old_wr_y_off := wr_y_off;

	// Increase counters
	inc(scnt);
	incrange(gcnt, 0, 4);
	incrange(mcnt, 0, 2);
	incrange(bcnt, 0, 3);
	incrange(ucnt, 0, 16);
	incrange(uscnt, 0, 4);

				screen_bg_color := BLUE + SCREEN_BG_BLACK;

	// Restore the processor registers and complete our interrupt
	closeIRQ();
end;

// Limit buggy x movement
procedure limit_x();
begin
	if (x < 8) then x := 8;
	if (x > 120) then x := 120;
end;

// Move buggy right
procedure buggy_right(incamount:byte);
begin
	x := x + incamount;
	xdir := x_right;
end;

// Move buggy left
procedure buggy_left(decamount:byte);
begin
	x := x - decamount;
	xdir := x_left;
end;

// Jump suspension
procedure jumpsuspend();
begin
	// Suspension
	suspension[sus_y] := y;
	wh_y := suspension[sus_wy];
	incrange(sus_y, 0, 3);
	incrange(sus_wy, 0, 3);
end;

// Find ground offset at x+offset
procedure find_ground(xoffset:byte);
begin
	for i := 0 to 8 do if (vbmTestPixel2(x+xoffset, 175+i) = 0) then yoff := i;
end;

// Main body, handle all initialization and
// game logic and joystick controls.
begin
	// Init music player
	musicplayer(1);

	// Initialize display mode to 19 column
	vbmSetDisplayMode(1);
	
	// Clear VBM
	vbmClear(0);
	
	// Clear color memory with WHITE and set MULTICOLOR flag
	vbmClearColor(WHITE + MULTICOLOR);
	
	// Set other colors, plus audio volume
	AUX_COLOR_AND_VOLUME := RED * 15 + 14;
	screen_bg_color := BLUE + SCREEN_BG_BLACK;

	for i:=0 to 20 do
	begin
		vbmSetPosition2(i*8, 184);
		p1 := int2ptr(ground_T[grndtile]);
		vbmDrawTile(p1);
		grndtile := grndtile xor 1;
	end;

	// Draw "stars"
	fori i := 0 to 5 do
	begin
		vbmDrawDot((random() >> 2) + 8, 40 + (i * 10));
		vbmDrawDot((random() >> 2) + 88 , 40 + (i * 10));
	end;

    // Draw "title" text
    vbmDrawSmallTextE(scoretitle, smallFont, 0, 0, 6);
    
	// Set upper two rows to hires single color
	fill(screen_col_loc, WHITE, 20);

	// Set up an raster interrupt to call outside visible screen,
	// params: IRQ function, raster line, PAL/NTSC (0/1)
	DisableVIC20IRQ();
	VIARasterIRQ(drawcar(), 124, 0);

	// Main game logic runs here in loop
	while(true) offpage do
	begin
		// Read joystick
		readjoy1();

		// Handle buggy drawing and moving when IRQ says the car has
		// been redrawn
		if (drawTree[d_car] = 0 and mcnt = 0) then
		begin
			case state of
				// Stationery
				s_stat:
					begin
						xdir := x_none;
						if (joy1 & JOY_RIGHT) then buggy_right(2);
						if (joy1 & JOY_LEFT) then buggy_left(2);
						if (joy1 & JOY_UP) then state := s_jump;
						drawTree[d_car] := 1;
					end;
				// In jump
				s_jump:
					begin
						if (xdir = x_right) then buggy_right(1);
						if (xdir = x_left) then buggy_left(1);
						if (jdir = 0) then y:=y-2 else y:=y+2;
						if (y < 110) then jdir := 1;
						if (y = 156) then
						begin
							jdir := 0;
							state := s_stat;
						end;

						drawTree[d_car] := 1;
					end;
			end;

			// make buggy stay inside limits			
			limit_x();

			// calculate new y offset for buggy and wheels
			find_ground(8);
			y_off := yoff;
			find_ground(2);
			wl_y_off := yoff;
			find_ground(12);
			wr_y_off := yoff;
			jumpsuspend();
		end;

		// Set up next ground tile when IRQ says ground needs new
		// tile
		if (drawTree[d_grnd] = 0) then
		begin
			drawTree[d_grnd] := 1;
			updowntile := updowntile + updowndir;
			if (updowntile = 7 or updowntile = 0) then begin
				updowndir := updowndir xor 254;
			end;
		end;

		// Set up next upper level tile when IRQ says ground needs new
		// tile
		if (drawTree[d_upper] = 0) then
		begin
			uppertile := uppertile + upperdir;
			if (uppertile = 7 or uppertile = 0) then begin
				upperdir := upperdir xor 254;
			end;
			bcdadd(score, scoreadd, 3);
			vbmdrawsmallbcd(score, addrNumbers, 6, 0, 3);
			drawTree[d_upper] := 1;
		end;

	end;
end.
