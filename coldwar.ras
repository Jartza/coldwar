program ColdWar;
var
   
	// Address of bitmap (screen and characters)
	@userdata $1000 $1FFF "Bitmap"

	// Export sprites, tiles and font from FLUFF files
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_carbody.bin"		0 	12	2	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_wheel.bin"  		80 	88	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_ground.bin" 		160	162	1	1
	@vbmexport	"res/sprites/sprites.flf" 	"export/sprite_updown.bin" 		120	128	1	1
	@export		"res/char/font4x8.flf" 		"export/font4x8.bin" 			0 	64

	// Memory addresses for sprites & tiles
	const addrCarBody:	address = $3400;
	const addrWheel:	address = addrCarBody + 192;
	const addrGround:	address = addrWheel + 64;
	const addrUpdown:	address = addrGround + 16;
	const addrFont:		address = addrUpdown + 64;

	// Include exported resources into binary
	carSprite: incbin("export/sprite_carbody.bin", addrCarBody);
	wheelSprite: incbin("export/sprite_wheel.bin", addrWheel);
	groundTile: incbin("export/sprite_ground.bin", addrGround);
	updownTile: incbin("export/sprite_updown.bin", addrUpdown);
	smallFont: incbin("export/font4x8.bin", addrFont);

	@startblock $2000 "game"

	// Pre-shifted address-table for car body sprite
	carbody_L: array[] of integer = (
		addrCarBody, addrCarBody+48, addrCarBody+96, addrCarBody+144
	);
	carbody_M: array[] of integer = (
		addrCarBody+16, addrCarBody+64, addrCarBody+112, addrCarBody+160
	);
	carbody_R: array[] of integer = (
		addrCarBody+32, addrCarBody+80, addrCarBody+128, addrCarBody+176
	);
	
	// Address-table for ground tiles
	ground_T: array[] of integer = (
		addrGround, addrGround + 8
	);

	// Address-table for up'n'down tiles
	updown_T: array[] of integer = (
		addrUpDown, addrUpDown+8, addrUpDown+16, addrUpDown+24,
		addrUpDown+32, addrUpDown+40, addrUpDown+48, addrUpDown+56
	);

	// Pre-shifter address-table for single wheel sprite
	wheel_L: array[] of integer = (
		addrWheel, addrWheel+16, addrWheel+32, addrWheel+48
	);
	wheel_R: array[] of integer = (
		addrWheel+8, addrWheel+24, addrWheel+40, addrWheel+56
	);


	// Misc constants
	const MULTICOLOR: byte = 8;

	// Draw tree index
	const d_car: 	byte = 0;
	const d_grnd:	byte = 1;

	// State index
	const s_stat:	byte = 0;
	const s_move:	byte = 1;
	const s_jump:	byte = 2;

	// X direction while jumping
	const x_none:	byte = 0;
	const x_left:	byte = 1;
	const x_right:	byte = 2;

	// Drawtree array which handles what to redraw
	drawTree: array[] of byte = (
		0, 0
	);

	// Global variables for all the game logic
	scnt: byte = 0;
	gcnt: byte = 0;
	mcnt: byte = 0;
	bcnt: byte = 0;
	x: byte = 50;
	y: byte = 156;
	yr: byte = 160;
	yl: byte = 160;
	oldyr: byte = 180;
	oldyl: byte = 180;
	oldx: byte = 168;
	oldy: byte = 156;
	dir: byte = 2;
	delay: byte;
	clr: byte = 0;
	grndtile: byte = 0;
	updowntile: byte = 0;
	updowndir: byte = 1;
	groundpos: byte = 0;
	groundmoved: byte = 0;
	i: byte = 0;
	p1: pointer;
	yoff: byte = 0;
	yoff_r: byte = 0;
	yoff_l: byte = 0;
	wheelbump: byte = 0;
	state: byte = 0;
	xdir: byte = 0;
	jdir: byte = 0;
    message: cstring = ("COLD WAR - little buggy game");

// Interrupt function that handles all the screen drawing
// starting from certain raster line to avoid flicker
//
procedure drawcar();
begin
	// Store the processors registers
	StartIRQ(0);

//				screen_bg_color := RED + SCREEN_BG_BLACK;

	// Clear previous car sprite
	vbmSetPosition2(oldx, oldy);
	vbmDrawSprite2E(carbody_L, carbody_M, carbody_R);
	
	// Clear old wheels
	vbmSetPosition2(oldx, oldy + oldyl + 6);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(oldx+10, oldy + oldyr + 7);
	vbmDrawSprite8E(wheel_L, wheel_R);

	if (scnt & 1) then
	begin
		vbmScreenShiftLeft(176,192);
		vbmScreenShiftLeft(176,192);
	end;

	// Stars
	if (bcnt = 0) then
	begin
		vbmScreenShiftLeft(40,41);
		vbmScreenShiftLeft(60,61);
		vbmScreenShiftLeft(70,71);
		vbmScreenShiftLeft(80,81);
		vbmScreenShiftLeft(100,101);
	end;
	
	// Draw new ground piece
	if (drawTree[d_grnd] = 1 and gcnt = 0) then
	begin
		vbmSetPosition2(152, 176);
		p1 := int2ptr(updown_T[updowntile]);
		vbmDrawTile(p1);
		drawTree[d_grnd] := 0;
	end;

	// Draw new car sprite
	vbmSetPosition2(x, y);
	vbmDrawSprite2E(carbody_L, carbody_M, carbody_R);
	
	// Draw wheels
	vbmSetPosition2(x, y + yl + 6);
	vbmDrawSprite8E(wheel_L, wheel_R);
	vbmSetPosition2(x+10, y + yr + 7);
	vbmDrawSprite8E(wheel_L, wheel_R);
	drawTree[d_car] := 0;
	oldx := x;
	oldy := y;
	oldyr := yr;
	oldyl := yl;

	// Increase counters
	inc(scnt);
	incrange(gcnt, 0, 8);
	incrange(mcnt, 0, 2);
	incrange(bcnt, 0, 2);

//				screen_bg_color := BLUE + SCREEN_BG_BLACK;

	// Restore the processor registers and complete our interrupt
	closeIRQ();
end;

// Limit buggy x movement
procedure limit_x();
begin
	if (x < 8) then x := 8;
	if (x > 120) then x := 120;
end;

// Move buggy right
procedure buggy_right();
begin
	x := x + 2;
	xdir := x_right;
end;

// Move buggy left
procedure buggy_left();
begin
	x := x - 2;
	xdir := x_left;
end;

// Find ground offset at x+offset
procedure find_ground(xoffset:byte);
begin
	for i := 0 to 8 do if (vbmTestPixel2(x+xoffset, 176+i) = 0) then yoff := i;
end;

// Main body, handle all initialization and
// game logic and joystick controls.
begin
	// Initialize display mode to 19 column
	vbmSetDisplayMode(1);
	
	// Clear VBM
	vbmClear(0);
	
	// Clear color memory with WHITE and set MULTICOLOR flag
	vbmClearColor(WHITE + MULTICOLOR);
	

	// Set other colors, plus audio volume
	AUX_COLOR_AND_VOLUME := RED * 15 + 15;
	screen_bg_color := BLUE + SCREEN_BG_BLACK;

	for i:=0 to 20 do
	begin
		vbmSetPosition2(i*8, 184);
		p1 := int2ptr(ground_T[grndtile]);
		vbmDrawTile(p1);
		grndtile := grndtile xor 1;
	end;
	
	// Draw "stars"
	vbmDrawDot(30,40);
	vbmDrawDot(151,60);
	vbmDrawDot(120,70);
	vbmDrawDot(71,80);
	vbmDrawDot(50,100);

    // Draw "title" text
    vbmDrawSmallTextE(message, smallFont, 5, 1, 6);
    
	// Set upper two rows to hires single color
	fill(screen_col_loc, WHITE, 20);

	// Set up an raster interrupt to call outside visible screen,
	// params: IRQ function, raster line, PAL/NTSC (0/1)
	DisableVIC20IRQ();
	VIARasterIRQ(drawcar(), 112, 0);

	// Main game logic runs here in loop
	while(true) offpage do
	begin
		// Read joystick
		readjoy1();
		
		// Basic movement and wheel wobble
		if ((drawTree[d_car] = 0 and mcnt = 0) and state = s_stat) then
		begin
			//screen_bg_color := GREEN + SCREEN_BG_BLACK;
			// calculate new y offset for buggy and wheels
			find_ground(8);
			y := 156 + yoff;
			find_ground(0);
			yl := (yoff >> 1) + wheelbump;
			find_ground(16);
			yr := (yoff >> 1) + wheelbump;
			wheelbump := wheelbump xor 1;

			// Joystick handling
			xdir := x_none;
			if (joy1 & JOY_RIGHT) then buggy_right();
			if (joy1 & JOY_LEFT) then buggy_left();
			if (joy1 & JOY_DOWN) then state := s_jump;
			//if (x = oldx) then x:=x-2;
			limit_x();
			//screen_bg_color := BLUE + SCREEN_BG_BLACK;
			drawTree[d_car] := 1;
		end;
		
		// Jump
		if ((drawTree[d_car] = 0 and mcnt = 0) and state = s_jump) then
		begin
			if (xdir = x_right) then buggy_right();
			if (xdir = x_left) then buggy_left();
			limit_x();
			if (jdir = 0) then y:=y-2 else y:=y+2;
			if (y < 140) then jdir := 1;
			if (y > 164) then
			begin
				jdir := 0;
				state := s_stat;
			end;
			drawTree[d_car] := 1;
		end;

		// Set up next ground tile
		if (drawTree[d_grnd] = 0) then
		begin
			drawTree[d_grnd] := 1;
			updowntile := updowntile + updowndir;
			if (updowntile = 7 or updowntile = 0) then begin
				updowndir := updowndir xor 254;
			end;
		end;
	end;
end.
